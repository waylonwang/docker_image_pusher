name: Specify Images

on:
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  MY_REGISTRY: "${{ secrets.MY_REGISTRY }}"
  MY_REGISTRY_USER: "${{ secrets.MY_REGISTRY_USER }}"
  MY_REGISTRY_PASSWORD: "${{ secrets.MY_REGISTRY_PASSWORD }}"

jobs:
  build:
    name: Pull
    runs-on: ubuntu-latest
    steps:
    - name: Install skopeo and jq
      run: |
        sudo apt-get update
        sudo apt-get install -y skopeo jq    

    - name: Docker Setup Buildx
      uses: docker/setup-buildx-action@v3

    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Read configuration, build, and push images to the target registry
      run: |
        docker login -u $MY_REGISTRY_USER -p $MY_REGISTRY_PASSWORD $MY_REGISTRY
        
        while IFS= read -r line || [ -n "$line" ]; do
            echo "读取行: $line"
            # 忽略空行与注释
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then
                continue
            fi
            
            # 获取镜像的完整名称，例如 kasmweb/nginx:1.25.3（命名空间/镜像名:版本号）
            image=$(echo "$line" | awk '{print $NF}')
            echo "原始镜像: $image"

            # 拆分出 registry, namespace, repository, tag
            registry=$(echo "$image" | awk -F'/' '{print $1}')
            repository_with_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            namespace_and_repo=$(echo "$image" | awk -F'/' '{if (NF==3) print $2"/"$3; else if (NF==2) print $1"/"$2; else print ""}')
            
            namespace=$(echo "$namespace_and_repo" | awk -F'/' '{print $1}')
            repo=$(echo "$repository_with_tag" | awk -F':' '{print $1}')
            tag=$(echo "$repository_with_tag" | awk -F':' '{if (NF>1) print $2; else print "latest"}')

            echo "解析出的注册表: $registry"
            echo "解析出的命名空间: $namespace"
            echo "解析出的仓库: $repo"
            echo "解析出的标签: $tag"
            
            # 目标地址
            target_image="$MY_REGISTRY/$namespace/$repo:$tag"
            echo "目标镜像: $target_image"

            # 获取源镜像的 manifest 并判断是否为多架构镜像
            source_manifest=$(skopeo inspect docker://$image)
            source_arch=$(echo "$source_manifest" | jq -r '.Architecture')

            if [ "$source_arch" == "null" ]; then
                # 多架构镜像，提取 linux/amd64 架构的 digest
                echo "镜像 $image 是多架构镜像。正在提取 linux/amd64 架构。"
                amd64_digest=$(echo "$source_manifest" | jq -r '.ManifestList[] | select(.platform.architecture == "amd64" and .platform.os == "linux") | .digest')
                echo "amd64_digest: $amd64_digest"

                source_layers=$(skopeo inspect docker://$image@$amd64_digest | jq -r '.Layers[]' | tr '\n' ' ')
            else
                # 单架构镜像，直接获取 layers
                echo "镜像 $image 是单架构镜像。"
                source_layers=$(echo "$source_manifest" | jq -r '.Layers[]' | tr '\n' ' ')
            fi

            # 输出 source_layers 的内容
            echo "源镜像 $image 的 layers:"
            if [ ${#source_layers} -le 100 ]; then
                echo "$source_layers"
            elif [ ${#source_layers} -le 200 ]; then
                echo "${source_layers:0:50}...${source_layers: -50}"
            else
                echo "${source_layers:0:50}...${source_layers:$((${#source_layers}/2-25)):50}...${source_layers: -50}"
            }

            # 获取目标镜像的 manifest 并判断是否为多架构镜像
            target_manifest=$(skopeo inspect --creds $MY_REGISTRY_USER:$MY_REGISTRY_PASSWORD docker://$target_image || echo "")
            if [ -n "$target_manifest" ]; then
                target_arch=$(echo "$target_manifest" | jq -r '.Architecture')
                if [ "$target_arch" == "null" ]; then
                    # 多架构镜像，提取 linux/amd64 架构的 digest
                    echo "目标镜像 $target_image 是多架构镜像。正在提取 linux/amd64 架构。"
                    target_amd64_digest=$(echo "$target_manifest" | jq -r '.ManifestList[] | select(.platform.architecture == "amd64" and .platform.os == "linux") | .digest')
                    echo "目标镜像 amd64_digest: $target_amd64_digest"

                    target_layers=$(skopeo inspect --creds $MY_REGISTRY_USER:$MY_REGISTRY_PASSWORD docker://$target_image@$target_amd64_digest | jq -r '.Layers[]' | tr '\n' ' ')
                else
                    # 单架构镜像，直接获取 layers
                    echo "目标镜像 $target_image 是单架构镜像。"
                    target_layers=$(echo "$target_manifest" | jq -r '.Layers[]' | tr '\n' ' ')
                fi
            else
                target_layers=""
            fi

            # 输出 target_layers 的内容
            echo "目标镜像 $target_image 的 layers:"
            if [ ${#target_layers} -le 100 ]; then
                echo "$target_layers"
            elif [ ${#target_layers} -le 200 ]; then
                echo "${target_layers:0:50}...${target_layers: -50}"
            else
                echo "${target_layers:0:50}...${target_layers:$((${#target_layers}/2-25)):50}...${target_layers: -50}"
            fi

            if [ -n "$target_layers" ]; then
                if [ "$source_layers" == "$target_layers" ]; then
                    echo "镜像 $target_image 已经存在于 $MY_REGISTRY 且各层一致。"
                    continue  # 如果镜像已经存在并且各层一致，跳过该镜像
                fi
            fi

            echo "镜像 $target_image 不存在于 $MY_REGISTRY 或者各层不匹配，继续拉取和推送。"
            
            echo "Docker 拉取 $image"
            docker pull $image
            
            echo "Docker 打标签 $image 为 $target_image"
            docker tag $image $target_image
            
            echo "Docker 推送 $target_image"
            docker push $target_image
        done < images.conf
